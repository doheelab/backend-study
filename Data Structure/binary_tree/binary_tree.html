<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.18.1/lib/index.min.js">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath@0.6.5/css/texmath.css">
<link rel="stylesheet" href="https://gitcdn.xyz/repo/goessner/mdmath/master/css/vscode-texmath.css">

</head>
<body class="markdown-body">
<h1 id="ec9e90eba38ceab5aceca1b0-ec9db4eca784-ed8ab8eba6acbinary-treeec9980-ed8ab8eba6ac-ec889ced9a8ctree-traversal-2" data-line="0" class="code-line">[자료구조] 이진 트리(Binary Tree)와 트리 순회(Tree Traversal)</h1>
<p data-line="2" class="code-line">이번 글에서는 <strong>이진 트리</strong>와 <strong>트리 순회</strong>에 대해서 알아보고, <code>JavaScript</code>를 이용해서 구현해보겠습니다.</p>
<h2 id="eab7b8eb9e98ed9484graph-2" data-line="4" class="code-line">그래프(Graph)</h2>
<ul>
<li data-line="6" class="code-line"><code>노드(node)</code>들과 노드들 사이를 연결하는 <code>간선(edge)</code>으로 구성되어 있습니다.</li>
<li data-line="7" class="code-line">그래프는 <code>root node</code>가 하나 있고, 각 노드에는 <code>child node</code>가 연결되어 있습니다.</li>
</ul>
<h2 id="ed8ab8eba6actree-2" data-line="9" class="code-line">트리(Tree)</h2>
<ul>
<li data-line="11" class="code-line"><code>트리</code>는 그래프의 일종으로, <code>cycle</code>이 없고, <strong>서로 다른 두 노드를 잇는 길이 하나 뿐인 그래프</strong>를 <strong>트리</strong>라고 합니다.</li>
<li data-line="12" class="code-line">노드가 <code>N개</code>인 트리는 항상 <code>N-1개</code>의 간선을 가집니다.</li>
<li data-line="13" class="code-line"><code>child</code>의 갯수가 2개로 제한되면 <strong>이진 트리</strong>라고 합니다.</li>
</ul>
<h2 id="ec9db4eca784-ed8ab8eba6acec9d98-eca285eba598-2" data-line="15" class="code-line">이진 트리의 종류</h2>
<ul>
<li data-line="17" class="code-line"><strong>Full Binary Tree</strong>: 각각의 노드가 <code>child</code>가 0개 혹은 2개</li>
<li data-line="18" class="code-line"><strong>Complete Binary Tree</strong>: 왼쪽 위에서부터 가득 차 있는 트리</li>
<li data-line="19" class="code-line"><strong>Perfect Binary Tree</strong>: 모든 내부 노드가 2개의 <code>children</code>을 가지고 있으며, <code>leaf node</code>의 <code>level</code>이 같은 트리</li>
</ul>
<h2 id="ec9db4eca784-ed8ab8eba6ac-ec889ced9a8c-ec958ceab3a0eba6aceca698binary-tree-traversal-2" data-line="21" class="code-line">이진 트리 순회 알고리즘(Binary Tree Traversal)</h2>
<p data-line="23" class="code-line"><strong>이진 트리 순회 알고리즘</strong>은 트리에 저장된 모든 값을 중복이나 빠짐없이 살펴보고 싶을 때 사용합니다. 이진 트리의 순회 방법 중 **깊이 우선 순회 방법(Depth First Traversal)**으로는 <code>전위 순회(Pre-order traversal)</code>, <code>정위 순회(In-order traversal)</code>, <code>후위 순회(Post-order traversal)</code>가 있으며, **너비 우선 순회 방법(Breadth First Traversal)**으로는 <code>레벨 순회</code>가 있습니다.</p>
<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/112273731-05464480-8cc1-11eb-9316-831b34246be2.png" /></div>
<div align="center">
  <i>Binary Tree 1 (from 코드없는프로그래밍)</i>
</div>
<br/>
<ul>
<li data-line="32" class="code-line"><code>Pre-order</code>: <strong>N</strong>LR</li>
<li data-line="33" class="code-line"><code>In-order</code>: L<strong>N</strong>R</li>
<li data-line="34" class="code-line"><code>Post-order</code>: LR<strong>N</strong></li>
<li data-line="35" class="code-line"><code>Level-order</code>: <strong>N</strong>LR</li>
</ul>
<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/112273743-0a0af880-8cc1-11eb-9953-1bf855e4dd17.png" /></div>
<div align="center">
  <i>Binary Tree 2 (from 코드없는프로그래밍)</i>
</div>
<br/>
<ul>
<li data-line="44" class="code-line"><code>Pre-order</code>: 1 2 4 5 3 6 7</li>
<li data-line="45" class="code-line"><code>In-order</code>: 4 2 5 1 6 3 7</li>
<li data-line="46" class="code-line"><code>Post-order</code>: 4 5 2 6 7 3 1</li>
<li data-line="47" class="code-line"><code>Level-order</code>: 1 2 3 4 5 6 7</li>
</ul>
<h2 id="ec9db4eca784-ed8ab8eba6ac-ec889ced9a8c-ec958ceab3a0eba6aceca698ec9d98-eab5aced9884-2" data-line="49" class="code-line">이진 트리 순회 알고리즘의 구현</h2>
<h2 id="ec9eaceab780eca081recursive-ebb0a9ebb295-2" data-line="51" class="code-line">재귀적(Recursive) 방법</h2>
<p data-line="53" class="code-line">이진 트리 순회 방법 중 <code>깊이 우선 순회 방법(BFS)</code>은 <strong>재귀적(Recursive)</strong> 혹은 <strong>반복적(Iterative)</strong> 방법으로 구현할 수 있습니다. 먼저 재귀적인 방법으로 구현해보겠습니다.</p>
<h3 id="ed8ab8eba6ac-eca095ec9d98ed9598eab8b0-2" data-line="55" class="code-line">트리 정의하기</h3>
<pre><code data-line="57" class="code-line language-javascript"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">val</span>)</span> {
    <span class="hljs-built_in">this</span>.val = val;
    <span class="hljs-built_in">this</span>.leftNode = <span class="hljs-literal">null</span>;
    <span class="hljs-built_in">this</span>.rightNode = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-function"><span class="hljs-title">setVal</span>(<span class="hljs-params">val</span>)</span> {
    <span class="hljs-built_in">this</span>.val = val;
  }

  <span class="hljs-function"><span class="hljs-title">setLeft</span>(<span class="hljs-params">node</span>)</span> {
    <span class="hljs-built_in">this</span>.leftNode = node;
  }

  <span class="hljs-function"><span class="hljs-title">setRight</span>(<span class="hljs-params">node</span>)</span> {
    <span class="hljs-built_in">this</span>.rightNode = node;
  }
}
</div></code></pre>
<h3 id="eca084ec9c84-ec889ced9a8cpre-order-4" data-line="79" class="code-line">전위 순회(Pre-order)</h3>
<pre><code data-line="80" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> recursivePreOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (!node) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-built_in">console</span>.log(node.val);
  <span class="hljs-built_in">this</span>.recursivePreOrder(node.leftNode);
  <span class="hljs-built_in">this</span>.recursivePreOrder(node.rightNode);
};
</div></code></pre>
<h3 id="eca095ec9c84-ec889ced9a8cin-order-2" data-line="91" class="code-line">정위 순회(In-order)</h3>
<pre><code data-line="92" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> recursiveInOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (!node) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-built_in">this</span>.recursiveInOrder(node.leftNode);
  <span class="hljs-built_in">console</span>.log(node.val);
  <span class="hljs-built_in">this</span>.recursiveInOrder(node.rightNode);
};
</div></code></pre>
<h3 id="ed9b84ec9c84-ec889ced9a8cpost-order-2" data-line="103" class="code-line">후위 순회(Post-order)</h3>
<pre><code data-line="104" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> recursivePostOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (!node) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-built_in">this</span>.recursivePostOrder(node.leftNode);
  <span class="hljs-built_in">this</span>.recursivePostOrder(node.rightNode);
  <span class="hljs-built_in">console</span>.log(node.val);
};
</div></code></pre>
<h2 id="ebb098ebb3b5eca081iterative-ebb0a9ebb295-2" data-line="115" class="code-line">반복적(Iterative) 방법</h2>
<p data-line="117" class="code-line">반복적인 방법으로 구현할 때는 **스택(stack)**을 사용합니다. 먼저 그림을 살펴보고, 이를 코드로 구현하겠습니다.</p>
<h3 id="eca084ec9c84-ec889ced9a8cpre-order-5" data-line="119" class="code-line">전위 순회(Pre-order)</h3>
<div style="text-align:center"><img src="http://108.61.119.12/wp-content/uploads/2014/10/binary-tree-1-pre-order-small.gif" /></div>
<div align="center">
  <i>Pre-order traversal from http://ejklike.github.io/</i>
</div>
<br/>
<pre><code data-line="129" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> iterativePreOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">let</span> stack = [];
  stack.push(node);
  <span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">let</span> pop_node = stack.pop();
    <span class="hljs-built_in">console</span>.log(pop_node.val);
    <span class="hljs-keyword">if</span> (pop_node.right) stack.push(pop_node.right);
    <span class="hljs-keyword">if</span> (pop_node.left) stack.push(pop_node.left);
  }
};
</div></code></pre>
<div align="center">
  <i>Pre-order traversal traversal from http://ejklike.github.io/</i>
</div>
<br/>
<div style="text-align:center"><img src="http://108.61.119.12/wp-content/uploads/2014/10/binary-tree-1-order-small.gif" /></div>
<div align="center">
  <i>In-order traversal from http://ejklike.github.io/</i>
</div>
<br/>
<pre><code data-line="158" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> iterativeInOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">let</span> crnt_node = node;
  <span class="hljs-keyword">let</span> stack = [];
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (crnt_node != <span class="hljs-literal">null</span>) {
      stack.push(crnt_node);
      crnt_node = crnt_node.left;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length &gt; <span class="hljs-number">0</span>) {
      crnt_node = stack.pop();
      <span class="hljs-built_in">console</span>.log(crnt_node.val);
      crnt_node = crnt_node.right;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">break</span>;
    }
  }
};
</div></code></pre>
<div align="center">
  <i>In-order traversal</i>
</div>
<br/>
<div style="text-align:center"><img src="http://108.61.119.12/wp-content/uploads/2014/10/binary-tree-1-post-order-small.gif" /></div>
<div align="center">
  <i>Post-order traversal from http://ejklike.github.io/</i>
</div>
<pre><code data-line="192" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> iterativePostOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">let</span> crnt_node = node;
  <span class="hljs-keyword">let</span> stack = [];
  <span class="hljs-keyword">let</span> last_visit_node = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (crnt_node != <span class="hljs-literal">null</span>) {
      stack.push(crnt_node);
      crnt_node = crnt_node.left;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.length &gt; <span class="hljs-number">0</span>) {
      peek_node = stack[stack.length - <span class="hljs-number">1</span>];
      <span class="hljs-keyword">if</span> (peek_node.right != <span class="hljs-literal">null</span> &amp;&amp; last_visit_node != peek_node.right) {
        crnt_node = peek_node.right;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(peek_node.val);
        last_visit_node = stack.pop();
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">break</span>;
    }
  }
};
</div></code></pre>
<div align="center">
  <i>Post-order traversal</i>
</div>
<br/>
<h2 id="eb8488ebb984-ec9ab0ec84a0-ec889ced9a8c-ebb0a9ebb295bfs-2" data-line="225" class="code-line">너비 우선 순회 방법(BFS)</h2>
<p data-line="227" class="code-line">이진 트리의 <code>너비 우선 순회</code>에는 <strong>레벨 순회</strong>가 있습니다. <strong>큐(queue)</strong> 자료구조를 사용하면 간단히 구현할 수 있습니다.</p>
<pre><code data-line="229" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> levelOrderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">let</span> queue = [];
  queue.push(node);
  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">let</span> pop_node = queue.shift();
    <span class="hljs-built_in">console</span>.log(pop_node.val);
    <span class="hljs-keyword">if</span> (pop_node.left) queue.push(pop_node.left);
    <span class="hljs-keyword">if</span> (pop_node.right) queue.push(pop_node.right);
  }
};

levelOrderTraversal(root)
</div></code></pre>
<h2 id="ebacb8eca09ced9280ec9db4-1-path-sum-ii-leetcode-2" data-line="247" class="code-line">문제풀이 1. Path Sum II <a href="https://leetcode.com/problems/path-sum-ii/description/" data-href="https://leetcode.com/problems/path-sum-ii/description/">(LeetCode)</a></h2>
<p data-line="249" class="code-line">Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return all <strong>root-to-leaf</strong> paths where each path's sum equals <code>targetSum</code>.</p>
<p data-line="251" class="code-line">(해석) 루트 노드와 정수 <code>targetSum</code>이 주여질 때, 루트 노드에서 <code>leaf</code>까지의 <code>path</code>가 지나는 노드의 합이 <code>targetSum</code>이 되도록 하는 모든 <code>path</code>를 찾아라.</p>
<h3 id="solution-2" data-line="253" class="code-line">Solution</h3>
<pre><code data-line="256" class="code-line language-javascript"><div><span class="hljs-keyword">var</span> pathSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, targetSum</span>) </span>{
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> [];
  }
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-keyword">var</span> repeat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, path, residual</span>) </span>{
    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;
    path.push(node.val);
    residual -= node.val;
    <span class="hljs-keyword">if</span> (residual == <span class="hljs-number">0</span> &amp;&amp; !node.left &amp;&amp; !node.right) result.push(<span class="hljs-built_in">Array</span>.from(path));
    repeat(node.left, path, residual);
    repeat(node.right, path, residual);
    path.pop();
  };
  repeat(root, [], targetSum);
  <span class="hljs-keyword">return</span> result;
};
</div></code></pre>
<h2 id="eab480eba0a8ebacb8ed95ad-leetcode-2" data-line="279" class="code-line">관련문항 (LeetCode)</h2>
<p data-line="281" class="code-line"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" data-href="https://leetcode.com/problems/binary-tree-inorder-traversal/">Binary Tree Inorder Traversal</a></p>
<h2 id="ecb0b8eab3a0ec9e90eba38c-2" data-line="283" class="code-line">참고자료</h2>
<p data-line="285" class="code-line">[1] <a href="https://laptrinhx.com/inorder-preorder-postorder-traversal-of-binary-tree-3322436720/" data-href="https://laptrinhx.com/inorder-preorder-postorder-traversal-of-binary-tree-3322436720/">Inorder Preorder Postorder Traversal of Binary Tree</a></p>
<p data-line="287" class="code-line">[2] <a href="https://gogomalibu.tistory.com/55" data-href="https://gogomalibu.tistory.com/55">[자료구조] Javascript로 Tree와 Tree 순회 구현하기</a></p>
<p data-line="289" class="code-line">[3] <a href="https://www.youtube.com/watch?v=bOZhvOc5xlQ&amp;list=PLDV-cCQnUlIaTA41swrZwgH4mX7iPxLH4&amp;index=1" data-href="https://www.youtube.com/watch?v=bOZhvOc5xlQ&amp;list=PLDV-cCQnUlIaTA41swrZwgH4mX7iPxLH4&amp;index=1">코딩테스트, 기초, 트리, Tree 소개</a></p>
<p data-line="291" class="code-line">[4] <a href="http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-2.html" data-href="http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-2.html">파이썬을 사용한 이진 트리와 순회 알고리즘 구현 (2)</a></p>
<p data-line="293" class="code-line">[5] <a href="https://baffinlee.com/leetcode-javascript/problem/path-sum-ii.html" data-href="https://baffinlee.com/leetcode-javascript/problem/path-sum-ii.html">113. Path Sum II</a></p>
<h2 id="eb8ba4ec9d8ceca3bceca09c-2" data-line="295" class="code-line">다음주제</h2>
<p data-line="297" class="code-line">Graph Traversal (DFS, BFS)</p>

</body></html>